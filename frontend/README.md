# Frontend (React + TypeScript)

The UI follows a Flux-style unidirectional data flow with a dedicated command
layer to guarantee undo/redo and collaborative consistency.

## Architectural Pillars

1. **State Store:** Redux Toolkit (or Zustand with middleware) maintains the
   canonical circuit, timeline, measurement, and UI state. All mutations flow
   through dispatched actions generated by command objects.
2. **Command Pattern:** Each circuit mutation is encapsulated as a Command with
   `execute()` and `undo()` methods. Commands serialize cleanly for history,
   collaboration, and persistence.
3. **Selectors & Derived Data:** Use memoized selectors to project Bloch stats,
   measurement summaries, and export payloads to keep components pure.
4. **Side Effects:** Thunks or sagas handle async work (calling the backend,
   streaming updates). Commands remain synchronous/honest; async wrappers
   dispatch `CommandExecuted`/`CommandFailed` events.

## Directory Sketch

```
frontend/
├── src/
│   ├── commands/          # Command classes (AddGate, UpdateParameter, …)
│   ├── store/             # Redux slices, selectors, middleware
│   ├── components/        # Presentational React components
│   ├── hooks/             # Custom hooks (e.g., keyboard bindings)
│   ├── services/          # API client (REST/WebSocket)
│   └── utils/             # Shared helpers (math, formatting)
└── tests/                 # Vitest/Jest suites
```

## Developer Tooling

- `npm run lint` – ESLint with React, hooks, and TypeScript rules (Prettier aligned).
- `npm run test` – Vitest configured with a jsdom environment and shared setup file.
- `npm run dev` – Vite dev server with fast HMR and React refresh checks enabled.

## Export & Sharing

Use the in-app export panel to generate:

1. **OpenQASM 3** dump of the active circuit
2. **Snapshot JSON** including Bloch vectors, probabilities, purity, and radius
3. Optional shareable circuit link (persists via the backend repository)

Noise sliders feed both simulation and measurement tooling. Toggle the "Apply noise
to simulation" checkbox to rerun snapshots with Kraus-based density evolution while
retaining measurement-only perturbations when desired.

Focus the Bloch readout on any qubit via the selector in the readout panel; the
backend performs a partial trace so snapshots, measurement samples, and exports
all align with the chosen subsystem.

Use the **Examples** drawer to drop in curated Bloch scenarios (equator states,
spirals, resets) and explore trajectories without building circuits from scratch.

Timeline scrubber displays gate context (name + targets) for each snapshot, and can
be navigated with arrow keys for quick scrubbing while keeping your hands on the keyboard.

Saved circuits now remember the last focused qubit, so reloading or sharing restores
the exact Bloch perspective you were analysing.

Sampling results now include a quick bar indicator, expectation and variance, plus a
preview of individual shot outcomes so you can sanity-check stochastic behaviour.

A mini timeline of per-shot outcomes (first 128 shots) helps spot runs of +/− results
when debugging noise or randomness.
Longest-run stats and switch counts accompany the measurement timeline, so you can quantify streakiness while inspecting stochastic runs.
Generate a share link from the export modal to embed the readout/timeline in external docs via the provided `<iframe>` snippet (append `&embed=1` to any shared circuit URL).
Gate cards expose all gate parameters for inline editing (e.g., RX θ, phase gate φ); changes marshal through the command/undo system so tweaks remain reversible.
